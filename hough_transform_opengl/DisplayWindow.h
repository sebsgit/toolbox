///
/// Rendering pipeline for Hough transform, using tesselation stage to populate the accumulator buffer.
/// The resolution of the Hough space is controlled and limited by the maximum available tesselation level.
///
/// The processing pipeline:
/// 1) Vertex input: edge points (// TODO: edge pixels should be generated by Canny detector)
/// 2) Tesselation stage generates the curves for the accumulator buffer, drawing (theta, rho) lines using the Hesse equation
///    For each input vertex (x, y) tesselation generates a single curve rho = x * cos(th) + y * sin(th)
/// 2a) blending used to update the accumulator buffer for each curve
/// 3) postprocess the accumulator buffer (TODO: render accumulator to a texture and sample in fragment shader)
///

#ifndef DISPLAYWINDOW_H
#define DISPLAYWINDOW_H

#include <QOpenGLShaderProgram>
#include <QOpenGLWidget>
#include <QOpenGLExtraFunctions>
#include <QtMath>

#include "MeshRenderBuffer.h"

//TODO: replace by Canny detector
class EdgePixelsGenerator : public Mesh
{
public:
    std::vector<GLfloat> generateVertexCoords(int w, int h) const override
    {
        return {
            w * 0.1f, h * 0.1f, 0.0f,
            w * 1.0f, h * 1.0f, 0.0f,
            w * 0.5f, h * 0.5f, 0.0f,
            w * 0.7f, h * 0.7f, 0.0f,
            w * 0.6f, h * 0.6f, 0.0f,

            w * 0.0f, h * 1.0f, 0.0f,
            w * 1.0f, h * 0.0f, 0.0f,
            w * 0.5f, h * 0.5f, 0.0f,
            w * 0.7f, h * 0.3f, 0.0f,
            w * 0.6f, h * 0.4f, 0.0f,

            w * 0.11f, h * 0.11f, 0.0f,
            w * 0.98f, h * 0.99f, 0.0f,
            w * 0.45f, h * 0.55f, 0.0f,
            w * 0.7f, h * 0.4f, 0.0f,


        };
    }

    std::vector<GLfloat> generateTextureCoordsInternal() const override
    {
        return {};
    }

    std::vector<GLuint> generateIndices() const override
    {
        const auto count {generateVertexCoords(0, 0).size() / 3};
        std::vector<GLuint> result (count);
        std::iota(result.begin(), result.end(), 0);
        return result;
    }

    GLint indexCount() const override
    {
        return static_cast<GLint>(generateIndices().size());
    }
};

class DisplayWindow : public QOpenGLWidget {
    Q_OBJECT
public:
    DisplayWindow(QWidget* parent = nullptr)
        : QOpenGLWidget(parent)
    {
        mesh_buffer_.reset(new MeshRenderBuffer(edge_pixels_));
    }

    ~DisplayWindow() override
    {
        makeCurrent();
        mesh_buffer_.reset();
        doneCurrent();
    }

protected:
    void initializeGL() override
    {
        shader_.addShaderFromSourceCode(QOpenGLShader::Vertex,
            "#version 430\n"
            "attribute highp vec4 vertex;\n"
            "uniform highp mat4 matrix;\n"
            "void main(void)\n"
            "{\n"
            "   gl_Position = matrix * vertex;\n"
            "}");

        shader_.addShaderFromSourceCode(QOpenGLShader::Fragment,
            "#version 430\n"
            "uniform float pixel_weight;\n"
            "void main(void)\n"
            "{\n"
            "   gl_FragColor = vec4(pixel_weight, pixel_weight, pixel_weight, pixel_weight);\n"
            "}");

        shader_.addShaderFromSourceCode(QOpenGLShader::TessellationControl,
            "#version 430\n"
            "layout (vertices = 1) out;\n"
            "uniform int tesselation_level;"
            "void main() {\n"
            "gl_TessLevelOuter[0] = tesselation_level;\n"
            "gl_TessLevelOuter[1] = tesselation_level;\n"
            "gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;\n"
            "}");

        shader_.addShaderFromSourceCode(QOpenGLShader::TessellationEvaluation,
            "#version 430\n"
            "layout (isolines) in;\n"
            "uniform float theta_max;"
            "void main() {\n"
            "const float tess_level_scale = gl_TessLevelOuter[0] * 1.0;"
            "const float theta_range_spacing = theta_max / tess_level_scale;\n"
            "const float theta_min = gl_TessCoord.y * theta_max;\n"
            "const float clip_min = -1.0;\n"
            "const float clip_max = 1.0;\n"
            "const float th = theta_min + gl_TessCoord.x * (theta_range_spacing);\n"
            "const float rho = gl_in[0].gl_Position.x * cos(th) + gl_in[0].gl_Position.y * sin(th);\n"
            "gl_Position = vec4((th / theta_max) * (clip_max - clip_min) + clip_min, rho, 0, 1);\n"
            "}");

        if (!shader_.link()) {
            qDebug() << "Program link error: " << shader_.log();
            exit(1);
        }

        mesh_buffer_->allocate(width(), height());

        gl_.initializeOpenGLFunctions();

        glGetIntegerv(GL_MAX_TESS_GEN_LEVEL, &max_tesselation_level_);

        qDebug() << "Max patch vertices: " << max_tesselation_level_;
        qDebug() << QString::fromLocal8Bit((const char*)glGetString(GL_VERSION));
    }

    void resizeGL(int w, int h) override
    {
        glViewport(0, 0, w, h);

        mesh_buffer_->update(width(), height());
    }

    void paintGL() override
    {
        renderAccumulatorBuffer(size(), *mesh_buffer_);
    }

    void renderAccumulatorBuffer(QSize target_size, MeshRenderBuffer &mesh_buffer)
    {
        glEnable(GL_BLEND);
        glBlendFunc(GL_ONE, GL_ONE);
        gl_.glBlendEquation(GL_FUNC_ADD);

        shader_.bind();

        qDebug() << "bind: " << glGetError();

        int vertexLocation = shader_.attributeLocation("vertex");
        int matrixLocation = shader_.uniformLocation("matrix");

        const auto edge_pixel_count {edge_pixels_.generateVertexCoords(0, 0).size() / 3};
        auto weight_loc  = shader_.uniformLocation("pixel_weight");
        shader_.setUniformValue(weight_loc, 1.0f / edge_pixel_count);

        const auto theta_max_loc = shader_.uniformLocation("theta_max");
        shader_.setUniformValue(theta_max_loc, static_cast<float>(M_PI));

        const auto tesselation_level_loc = shader_.uniformLocation("tesselation_level");
        shader_.setUniformValue(tesselation_level_loc, max_tesselation_level_);

        QMatrix4x4 viewMat;
        viewMat.ortho(QRect(0, 0, target_size.width(), target_size.height()));
        glViewport(0, 0, target_size.width(), target_size.height());
        shader_.setUniformValue(matrixLocation, viewMat);

        mesh_buffer.bindVertexBuffer();
        shader_.enableAttributeArray(vertexLocation);
        shader_.setAttributeBuffer(vertexLocation, GL_FLOAT, 0, 3);

        mesh_buffer.bindIndexBuffer();

        gl_.glPatchParameteri(GL_PATCH_VERTICES, 1);
        glDrawElements(GL_PATCHES, mesh_buffer.indexCount(), GL_UNSIGNED_INT, nullptr);

        qDebug() <<"draw:"<< glGetError();

        shader_.disableAttributeArray(vertexLocation);

        mesh_buffer.release();
        shader_.release();

        glDisable(GL_BLEND);
    }

private:
    QOpenGLExtraFunctions gl_;
    QOpenGLShaderProgram shader_;
    EdgePixelsGenerator edge_pixels_;
    std::unique_ptr<MeshRenderBuffer> mesh_buffer_;
    GLint max_tesselation_level_ {8};
};

#endif // DISPLAYWINDOW_H
